<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>å¹»éœ“å¯¹å†³ï¼šé”¤Â·é•°Â·åŒ…</title>
    <!-- å¼•å…¥ç§‘å¹»æ•°å­—å­—ä½“ï¼Œä¸­æ–‡ä½¿ç”¨ç³»ç»Ÿé»‘ä½“ä»¥ä¿æŒæ¸…æ™° -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #00f3ff; /* é’è‰² */
            --secondary-color: #ff0055; /* ç«çº¢ */
            --bg-color: #050508;
            --glass-bg: rgba(0, 20, 40, 0.6);
        }

        body { 
            margin: 0; overflow: hidden; background-color: var(--bg-color); 
            font-family: 'Orbitron', 'Microsoft YaHei', sans-serif; 
            user-select: none; 
        }
        
        /* èƒŒæ™¯ç½‘æ ¼æ‰«æçº¿ */
        body::after {
            content: " ";
            display: block;
            position: absolute; top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.03), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.03));
            z-index: 1;
            background-size: 100% 3px, 3px 100%;
            pointer-events: none;
        }

        /* UI å±‚ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            z-index: 10;
        }

        /* HUD é¡¶éƒ¨æ¯”åˆ†æ¿ */
        #scoreboard {
            display: flex; justify-content: center; align-items: center; gap: 40px;
            padding: 15px 0;
            background: linear-gradient(90deg, transparent 0%, var(--glass-bg) 20%, var(--glass-bg) 80%, transparent 100%);
            backdrop-filter: blur(5px);
            border-bottom: 1px solid rgba(0, 243, 255, 0.2);
            margin-top: 20px;
        }
        .score-box { 
            text-align: center; color: var(--primary-color); 
            width: 180px; position: relative;
        }
        .score-box.enemy { color: var(--secondary-color); }
        
        .score-label { 
            font-size: 14px; letter-spacing: 2px; opacity: 0.8; margin-bottom: 5px;
            font-weight: bold;
        }
        .score-num { 
            font-size: 56px; font-weight: 900; line-height: 1; 
            text-shadow: 0 0 15px currentColor;
        }
        .vs-tag { 
            font-size: 32px; color: #fff; font-style: italic; opacity: 0.5; font-family: 'Orbitron';
        }

        /* ä¸­å¿ƒå€’è®¡æ—¶ä¸ç»“æœ */
        #center-display {
            position: absolute; top: 45%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; width: 100%;
            pointer-events: none;
        }
        #countdown {
            font-size: 200px; font-weight: 900; color: #fff;
            text-shadow: 0 0 20px #fff, 0 0 50px var(--primary-color);
            display: none;
            animation: pulse 0.8s infinite;
        }
        #round-result {
            font-size: 90px; font-weight: 900; 
            letter-spacing: 5px; display: none;
            text-shadow: 0 0 30px currentColor;
            -webkit-text-stroke: 2px rgba(0,0,0,0.5);
        }

        /* æ‘„åƒå¤´å…¨æ¯æ¡† - å¢å¼ºç‰ˆ */
        #cam-wrapper {
            position: absolute; bottom: 30px; right: 30px;
            width: 280px; height: 210px;
            border: 1px solid rgba(0, 243, 255, 0.3);
            background: rgba(0,0,0,0.8);
            transform: scaleX(-1); /* é•œåƒ */
            /* ç§‘æŠ€æ„Ÿåˆ‡è§’ */
            clip-path: polygon(
                20px 0, 100% 0, 100% calc(100% - 20px), 
                calc(100% - 20px) 100%, 0 100%, 0 20px
            );
        }
        /* æ‘„åƒå¤´å››è§’è£…é¥° */
        #cam-wrapper::before {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            border: 2px solid var(--primary-color);
            clip-path: polygon(
                0 30px, 0 0, 30px 0, 
                calc(100% - 30px) 0, 100% 0, 100% 30px,
                100% calc(100% - 30px), 100% 100%, calc(100% - 30px) 100%,
                30px 100%, 0 100%, 0 calc(100% - 30px)
            );
            z-index: 2;
        }
        
        video { width: 100%; height: 100%; object-fit: cover; opacity: 0.7; }
        
        /* æ‰«æçº¿åŠ¨ç”» */
        .scan-line {
            position: absolute; top: 0; left: 0; width: 100%; height: 2px;
            background: rgba(0, 243, 255, 0.8);
            box-shadow: 0 0 10px var(--primary-color);
            animation: scan 2s linear infinite;
            z-index: 3;
            opacity: 0.5;
        }

        /* åº•éƒ¨çŠ¶æ€æ¡ */
        #status-bar {
            position: absolute; bottom: 30px; left: 30px;
            color: #fff; font-size: 18px;
            background: linear-gradient(90deg, var(--glass-bg), transparent);
            padding: 15px 30px;
            border-left: 4px solid var(--primary-color);
            text-shadow: 0 0 5px var(--primary-color);
        }
        .gesture-hint { font-size: 14px; color: #aaa; margin-top: 5px; }

        /* ç»“ç®—é¢æ¿ */
        #game-over-panel {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(15px);
            display: none; flex-direction: column;
            align-items: center; justify-content: center;
            pointer-events: auto; z-index: 100;
        }
        #final-title { 
            font-size: 80px; font-weight: 900; margin-bottom: 10px; 
            letter-spacing: 5px;
        }
        #final-score { font-size: 40px; color: #fff; margin-bottom: 30px; font-family: 'Orbitron'; }
        #decryption { 
            font-size: 18px; color: var(--primary-color); margin-bottom: 60px; 
            border: 1px solid var(--primary-color); padding: 10px 20px;
            background: rgba(0, 243, 255, 0.1);
        }
        
        button {
            padding: 15px 50px; font-size: 22px; cursor: pointer;
            background: var(--primary-color); color: #000; font-weight: 900;
            border: none; font-family: 'Microsoft YaHei', sans-serif;
            clip-path: polygon(15px 0, 100% 0, 100% calc(100% - 15px), calc(100% - 15px) 100%, 0 100%, 0 15px);
            transition: 0.3s;
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.4);
        }
        button:hover { 
            background: #fff; 
            box-shadow: 0 0 40px #fff;
            transform: scale(1.05);
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }
        @keyframes scan {
            0% { top: 0%; opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { top: 100%; opacity: 0; }
        }
    </style>
    
    <!-- Three.js æ ¸å¿ƒ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- åå¤„ç†ä¾èµ– (Bloom Effect) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui-layer">
        <div id="scoreboard">
            <div class="score-box">
                <div class="score-label">ç©å®¶ (P1)</div>
                <div id="score-player" class="score-num">0</div>
            </div>
            <div class="vs-tag">VS</div>
            <div class="score-box enemy">
                <div class="score-label">ç³»ç»Ÿ (AI)</div>
                <div id="score-ai" class="score-num">0</div>
            </div>
        </div>
        
        <div id="center-display">
            <div id="countdown">3</div>
            <div id="round-result"></div>
        </div>

        <div id="status-bar">
            <div>ç³»ç»ŸçŠ¶æ€: <span id="gesture-name" style="color:#00f3ff; font-weight:bold;">æ­£åœ¨åˆå§‹åŒ–...</span></div>
            <div class="gesture-hint">æ“ä½œæŒ‡å—: âœŠ=é”¤å­ | ğŸ–=åŒ–å¦†åŒ… | âœŒï¸=é•°åˆ€</div>
        </div>
    </div>

    <div id="cam-wrapper">
        <div class="scan-line"></div>
        <video id="input_video"></video>
    </div>

    <div id="game-over-panel">
        <div id="final-title">ä»»åŠ¡å®Œæˆ</div>
        <div id="final-score">0 - 0</div>
        <div id="decryption">è§£å¯†ç»“æœ: é•°åˆ€ç»ˆç»“è€…åè®®å·²å¯åŠ¨</div>
        <button onclick="restartGame()">é‡å¯ç³»ç»Ÿ</button>
    </div>

<script>
    // ================= 0. éŸ³æ•ˆç³»ç»Ÿ (AudioContext) =================
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    
    function playTone(freq, type, duration, vol = 0.1) {
        if(audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type; 
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        
        gain.gain.setValueAtTime(vol, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);

        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    }

    const SFX = {
        COUNTDOWN: () => playTone(800, 'square', 0.1, 0.05),
        GO: () => playTone(1200, 'square', 0.3, 0.1),
        WIN: () => {
            playTone(440, 'sine', 0.1);
            setTimeout(() => playTone(554, 'sine', 0.1), 100);
            setTimeout(() => playTone(659, 'sine', 0.4), 200);
        },
        LOSE: () => {
            playTone(200, 'sawtooth', 0.3);
            setTimeout(() => playTone(150, 'sawtooth', 0.5), 150);
        },
        DRAW: () => playTone(300, 'triangle', 0.3)
    };

    // ================= 1. æ¸¸æˆé…ç½® (ä¸­æ–‡) =================
    const GESTURES = {
        ROCK: 'é‡é”¤ (HAMMER)',
        PAPER: 'åŒ–å¦†åŒ… (BAG)',
        SCISSORS: 'æ­»ç¥é•°åˆ€ (SICKLE)',
        UNKNOWN: 'ç­‰å¾…æ‰‹åŠ¿ä¿¡å·...'
    };

    let gameState = {
        playerScore: 0,
        aiScore: 0,
        isGameOver: false,
        currentGesture: GESTURES.UNKNOWN,
    };

    // ================= 2. Three.js èµ›åšæœ‹å…‹åœºæ™¯ =================
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050508, 0.025);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 8;
    camera.position.y = 1;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.toneMapping = THREE.ReinhardToneMapping;
    document.body.appendChild(renderer.domElement);

    // --- åå¤„ç†ï¼šè¾‰å…‰æ•ˆæœ (Bloom) ---
    const renderScene = new THREE.RenderPass(scene, camera);
    const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    bloomPass.threshold = 0.1;
    bloomPass.strength = 1.2; // è°ƒæ•´è¾‰å…‰å¼ºåº¦
    bloomPass.radius = 0.5;

    const composer = new THREE.EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);

    // --- åœºæ™¯è£…é¥° ---
    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);
    
    // éœ“è™¹ç¯å…‰
    const blueLight = new THREE.PointLight(0x00f3ff, 2, 50);
    blueLight.position.set(-5, 5, 5);
    scene.add(blueLight);
    
    const pinkLight = new THREE.PointLight(0xff0055, 2, 50);
    pinkLight.position.set(5, 5, 5);
    scene.add(pinkLight);

    // åœ°é¢ç½‘æ ¼ (Grid)
    const gridHelper = new THREE.GridHelper(100, 50, 0x00f3ff, 0x111111);
    gridHelper.position.y = -2;
    scene.add(gridHelper);

    // ç²’å­èƒŒæ™¯ (æ˜Ÿç©ºç©¿æ¢­)
    const starsGeo = new THREE.BufferGeometry();
    const starCount = 1500;
    const posArray = new Float32Array(starCount * 3);
    for(let i=0; i<starCount * 3; i++) {
        posArray[i] = (Math.random() - 0.5) * 80; 
    }
    starsGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
    const starsMat = new THREE.PointsMaterial({
        size: 0.15, color: 0x00f3ff, transparent: true, opacity: 0.6
    });
    const starMesh = new THREE.Points(starsGeo, starsMat);
    scene.add(starMesh);

    // --- 3D æ¨¡å‹æ„å»º (ä½¿ç”¨å‘å…‰æè´¨) ---
    const neonBlueMat = new THREE.MeshStandardMaterial({ 
        color: 0x000000, emissive: 0x00f3ff, emissiveIntensity: 1.5, wireframe: true 
    });
    const neonPinkMat = new THREE.MeshStandardMaterial({ 
        color: 0x000000, emissive: 0xff0055, emissiveIntensity: 1.5, wireframe: true 
    });
    const neonYellowMat = new THREE.MeshStandardMaterial({ 
        color: 0x000000, emissive: 0xffff00, emissiveIntensity: 1.5, wireframe: true 
    });

    const models = {};

    // 1. é”¤ (HAMMER)
    const hammerGroup = new THREE.Group();
    const hHandle = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 3, 8), neonBlueMat);
    const hHead = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2.5, 1.5), neonBlueMat);
    hHead.position.y = 1.5;
    hHead.rotation.z = Math.PI / 2;
    hammerGroup.add(hHandle, hHead);
    models[GESTURES.ROCK] = hammerGroup;

    // 2. åŒ–å¦†åŒ… (BAG) - èƒ½é‡çƒä½“
    const bagGroup = new THREE.Group();
    const bMain = new THREE.Mesh(new THREE.IcosahedronGeometry(1.8, 1), neonPinkMat);
    const bRing = new THREE.Mesh(new THREE.TorusGeometry(2.2, 0.05, 16, 100), neonPinkMat);
    bRing.rotation.x = Math.PI / 2;
    bagGroup.add(bMain, bRing);
    models[GESTURES.PAPER] = bagGroup;

    // 3. é•°åˆ€ (SICKLE)
    const sickleGroup = new THREE.Group();
    const sHandle = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 3.5), neonYellowMat);
    const sBlade = new THREE.Mesh(new THREE.TorusGeometry(1.2, 0.15, 8, 30, Math.PI), neonYellowMat);
    sBlade.position.set(-0.8, 1.5, 0);
    sBlade.rotation.z = -Math.PI / 3;
    sickleGroup.add(sHandle, sBlade);
    models[GESTURES.SCISSORS] = sickleGroup;

    // å®¹å™¨
    const aiContainer = new THREE.Group();
    aiContainer.position.set(3.5, 0, 0);
    aiContainer.rotation.y = -0.5;
    scene.add(aiContainer);

    const playerContainer = new THREE.Group();
    playerContainer.position.set(-3.5, 0, 0);
    playerContainer.rotation.y = 0.5;
    scene.add(playerContainer);

    // ================= 3. æ¸¸æˆé€»è¾‘ =================
    const elPlayerScore = document.getElementById('score-player');
    const elAiScore = document.getElementById('score-ai');
    const elCountdown = document.getElementById('countdown');
    const elResult = document.getElementById('round-result');
    const elGameOver = document.getElementById('game-over-panel');
    const elFinalTitle = document.getElementById('final-title');
    const elFinalScore = document.getElementById('final-score');

    function showModel(container, gesture) {
        container.clear();
        if (models[gesture]) {
            const m = models[gesture].clone();
            container.add(m);
            m.scale.set(0.1, 0.1, 0.1);
            m.userData = { anim: 0 };
        }
    }

    function startRound() {
        if (gameState.isGameOver) return;
        if (gameState.playerScore >= 3 || gameState.aiScore >= 3) {
            endGame();
            return;
        }

        aiContainer.clear();
        playerContainer.clear();
        elResult.style.display = 'none';
        elCountdown.style.display = 'block';
        
        let count = 3;
        elCountdown.innerText = count;
        SFX.COUNTDOWN();

        const timer = setInterval(() => {
            count--;
            if (count > 0) {
                elCountdown.innerText = count;
                SFX.COUNTDOWN();
            } else {
                clearInterval(timer);
                elCountdown.style.display = 'none';
                SFX.GO();
                resolveRound();
            }
        }, 1000);
    }

    function resolveRound() {
        const playerMove = gameState.currentGesture;
        const moves = [GESTURES.ROCK, GESTURES.PAPER, GESTURES.SCISSORS];
        const aiMove = moves[Math.floor(Math.random() * 3)];

        showModel(playerContainer, playerMove);
        showModel(aiContainer, aiMove);

        let resultText = "";
        let color = "#fff";

        if (playerMove === GESTURES.UNKNOWN) {
            resultText = "ä¿¡å·ä¸¢å¤±";
            gameState.aiScore++;
            color = "#ff0055";
            SFX.LOSE();
        } else if (playerMove === aiMove) {
            resultText = "å¹³å±€";
            color = "#ffff00";
            SFX.DRAW();
        } else {
            if (
                (playerMove === GESTURES.ROCK && aiMove === GESTURES.SCISSORS) ||
                (playerMove === GESTURES.SCISSORS && aiMove === GESTURES.PAPER) ||
                (playerMove === GESTURES.PAPER && aiMove === GESTURES.ROCK)
            ) {
                resultText = "å›åˆèƒœåˆ©";
                gameState.playerScore++;
                color = "#00f3ff";
                SFX.WIN();
            } else {
                resultText = "å›åˆå¤±è´¥";
                gameState.aiScore++;
                color = "#ff0055";
                SFX.LOSE();
            }
        }

        elPlayerScore.innerText = gameState.playerScore;
        elAiScore.innerText = gameState.aiScore;
        elResult.innerText = resultText;
        elResult.style.color = color;
        elResult.style.textShadow = `0 0 30px ${color}`;
        elResult.style.display = 'block';

        setTimeout(startRound, 3000);
    }

    function endGame() {
        gameState.isGameOver = true;
        elGameOver.style.display = 'flex';
        
        const win = gameState.playerScore > gameState.aiScore;
        elFinalTitle.innerText = win ? "å¤§è·å…¨èƒœ" : "ä»»åŠ¡å¤±è´¥";
        elFinalTitle.style.color = win ? "#00f3ff" : "#ff0055";
        elFinalTitle.style.textShadow = win ? "0 0 40px #00f3ff" : "0 0 40px #ff0055";
        elFinalScore.innerText = `æœ€ç»ˆæ¯”åˆ† ${gameState.playerScore} - ${gameState.aiScore}`;
        
        if(win) SFX.WIN(); else SFX.LOSE();
    }

    window.restartGame = function() {
        gameState.playerScore = 0;
        gameState.aiScore = 0;
        gameState.isGameOver = false;
        elPlayerScore.innerText = 0;
        elAiScore.innerText = 0;
        elGameOver.style.display = 'none';
        setTimeout(startRound, 1000);
    };

    // ================= 4. MediaPipe æ‰‹åŠ¿ =================
    const videoElement = document.getElementById('input_video');
    const elGestureName = document.getElementById('gesture-name');

    function onResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            const isIndexOpen = landmarks[8].y < landmarks[6].y;
            const isMiddleOpen = landmarks[12].y < landmarks[10].y;
            const isRingOpen = landmarks[16].y < landmarks[14].y;
            const isPinkyOpen = landmarks[20].y < landmarks[18].y;

            let count = 0;
            if (isIndexOpen) count++;
            if (isMiddleOpen) count++;
            if (isRingOpen) count++;
            if (isPinkyOpen) count++;

            if (count <= 1) gameState.currentGesture = GESTURES.ROCK;
            else if (count === 2) gameState.currentGesture = GESTURES.SCISSORS;
            else if (count >= 4) gameState.currentGesture = GESTURES.PAPER;
            else gameState.currentGesture = GESTURES.UNKNOWN;
        } else {
            gameState.currentGesture = GESTURES.UNKNOWN;
        }
        elGestureName.innerText = gameState.currentGesture;
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 320, height: 240
    });
    cameraUtils.start();

    // ================= 5. åŠ¨ç”»å¾ªç¯ =================
    function animate() {
        requestAnimationFrame(animate);

        // æ˜Ÿç©ºç§»åŠ¨
        const positions = starMesh.geometry.attributes.position.array;
        for(let i=1; i<positions.length; i+=3) {
            positions[i+1] += 0.15; 
            if(positions[i+1] > 20) positions[i+1] = -50;
        }
        starMesh.geometry.attributes.position.needsUpdate = true;

        // åœ°é¢ç§»åŠ¨æ•ˆæœ
        gridHelper.position.z = (Date.now() * 0.005) % 10;

        // æ¨¡å‹åŠ¨ç”»
        const time = Date.now() * 0.002;
        [playerContainer, aiContainer].forEach(container => {
            if(container.children.length > 0) {
                const mesh = container.children[0];
                mesh.rotation.y += 0.02;
                mesh.rotation.x = Math.sin(time) * 0.1;
                
                if (mesh.userData.anim !== undefined && mesh.userData.anim < 1) {
                    mesh.userData.anim += 0.05;
                    const s = mesh.userData.anim;
                    mesh.scale.set(s,s,s);
                }
            }
        });

        composer.render();
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
    setTimeout(startRound, 3000); 

</script>
</body>
</html>
